# 一、Java中的位运算？【这一章节是为了引出二进制的重要性，同时了解原码、反码、补码如何与二进制进行结合使用】

（1）示例：请查看下面的代码，然后回答a、b、c、d的值是多少？

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 1 >> 2;
       int b = -1 >> 2;
       int c = 1 << 2;
       int d = -1 << 2;
       int e = 3 >>> 2;

       System.out.println(a);
       System.out.println(b);
       System.out.println(c);
       System.out.println(d);
       System.out.println(e);
    }
}
// 解析：这里面的 >> 是算数位左/右移；>>> 是无符号位移
```

（2）位运算的思考题：请回答在java中，下面表达式运算的结果是：位操作

```
~2 = ? // 按位取反
2&3 = ？// 按位与
2|3 = ？ // 按位或
~-5 = ？
13&7 = ？
5|4 = ？
-3^3 = ？// 按位异或
```

#### 是不是看完之后无法回答上面的问题？这就是涉及到了计算机底层的二进制【原码、反码、补码】，所以，复习到这里的时候，请你去先复习day1.0Java重点、难点---原码、反码、补码，然后再回来往下看





#### 请先复习day1.0

#### 请先复习day1.0

#### 请先复习day1.0





# 二、运算详解？【原码、反码、补码运算转换】

#### 计算机中的运算方式：涉及到计算机运算，无论是加减乘除、还是按位与、按位或等等，都是以为补码的方式进行的

#### java中有7个位运算（按位与&、按位或|、按位异或^、按位取反~）

你一定很奇怪为什么按位与、按位或、按位异或和逻辑与、逻辑或、逻辑异或都是用同样的符号进行表示的，那么在以后，我怎么确定它是按位还是逻辑呢？

#### 1、两边是常量值，就是按位

#### 2、两边是条件表达式，就是逻辑

## 一、按位与&、按位或|、按位异或^、按位取反~，他们的运算规则是：

按位与&：两位全为1，结果才为1，否则为0

按位或|：两位有一位为1，结果就为1，否则为0

按位异或^：两位一个为0，一个为1，结果才为1，否则为0

按位取反~：0变为1，1变为0

1、实际示例：请你求出 2&3 的值？

解析：我们在day1.0中已经提到了，计算机在进行运算【无论是按位与、安慰或、加减乘除等】的时候，都是以补码的方式来进行运算的

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 2&3;
        // 思路解析：计算机中的所有运算，全部都是以补码的方式进行的
        /*
        先将数据转换为二进制，然后利用二进制与补码之间的关系
        再利用数据类型的位数来确定数据
        */
        // 1、先得到2的原码：00000000 00000000 00000000 00000010
        // 2、再得到3的原码：00000000 00000000 00000000 00000011
        // 3、因为2和3都是正数，正数的原码、反码、补码都是一致的【三码合一】
        // 4、按位与&：两位全为1，结果才为1，否则为0
        // 5、2&3结果是运算后的补码：000000000 00000000 00000000 00000010
        // 6、但是要注意：我们在看运算结果的时候，要看它的原码，而不是补码
        // 7、但是上述例子是正数：因为正数的原码、反码、补码都是一致的【三码合一】
        // 8、所以上述例子的原码就是补码
        System.out.println(a); // 输出：2【最终的补码会被解析为原码，之后可以自己转换为10#】
    }
}

```



2、实际示例：请你求出~-2的值？【补码是正数，不需要推导】

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = ~-2;
        // 负数2的二进制表示：10000000 00000000 00000000 00000010
        // 负数2的反码：     11111111 11111111 11111111 11111101
        // 负数2的补码：     11111111 11111111 11111111 11111110 【只需反码最低位+1】
        // ~-2的结果：      00000000 00000000 00000000 00000001【运算后的补码】
        // 但是要注意：我们需要的是原码，但是补码是正数，正数的原码、反码、补码都一致
        System.out.println(a); // 输出：1
    }
}
```

3、实际示例：请你求出~2的值？【补码是负数，需要逆转为原码】

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = ~2;
        // 2的二进制表示：00000000 00000000 00000000 00000010
        // 2的反码：     00000000 00000000 00000000 00000010
        // 2的补码：     00000000 00000000 00000000 00000010
        // ~2的结果：    11111111 11111111 11111111 11111101 【运算后的补码】
        // 但是我们要看原码，上述~2的结果是一个负数，需要逆转回去
        // ~2运算后的反码：    11111111 11111111 11111111 11111100 【负数反码=补码-1】
        // ~2运算后的原码：    10000000 00000000 00000000 00000011 【符号位不变，其它取反】
        System.out.println(a); // 输出：-3
    }
}
```

#### 这里解释一下为什么需要负数需要进行逆转？

解析：因为我们使用的是补码来进行运算的，如果表达式使用补码运算出来属于是正数，那么运算在这一步就已经终止了【因为正数的补码、原码、反码统一】！！

但是表达式运算出来是负数就不一样了，我们虽然运算出来了补码，但是我们需要看的是原码，而你的补码为负数，就不符合“三码合一”的情况，原码肯定和补码不一致，所以还需要对这个补码再运算，最终转换为原码才可以！



练习题：

1、求2|3的值？

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 2|3;
        // 2的原码：00000000 00000000 00000000 00000010
        // 3的原码：00000000 00000000 00000000 00000011
        // 2|3：   00000000 00000000 00000000 00000011【运算后的补码是正数】
        // 正数的补码和原码都是一致的
        // 所以2|3的结果是：00000000 00000000 00000000 00000011
        System.out.println(a); // 输出：3
    }
}
```

2、求2^3的值？

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 2^3;
        // 2的原码：00000000 00000000 00000000 00000010
        // 3的原码：00000000 00000000 00000000 00000011
        // 2^3：   00000000 00000000 00000000 00000001【运算后的补码是正数】
        // 正数的补码和原码都是一致的
        // 所以2^3的结果是：00000000 00000000 00000000 00000001
        System.out.println(a); // 输出：1
    }
}
```





# 三、位运算符？

还有3个位运算符：算术右移>>、算术左移<<、无符号位移>>>【注意：没有<<<】

1、算术右移>>规则：低位溢出【溢出：就是扔掉、删除的意思】，符号位不变，并用符号位补溢出的高位

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 1>>2;
        // 将int类型的1向右边位移两位
        // 1的原码是：00000000 00000000 00000000 00000001
        // 1>>2的意思是：将1的原码低位上的2位数字往右边位移2位
        /*
        1>>2：00000000 00000000 00000000 000000 "01" 【"01"被位移/溢出2位】
        然后有:00000000 00000000 00000000 000000 ""   【“”中需要使用符号位填补溢出的位】
        结果是:00000000 00000000 00000000 00000000 【1>>2结果就是0】
         */
        System.out.println(a);
    }
}

```

2、算数左移<<：符号位不变，低位补0

```java
public class BinaryChange {
    public static void main(String[] args) {
       int a = 1<<2;
        // 将int类型的1向左边位移两位
        // 1的原码是：00000000 00000000 00000000 00000001
        // 1<<2的意思是：将1的原码低位上的2位数字往左边位移2位
        /*
        1<<2：00000000 00000000 00000000 000000 "01"【"01"向左位移2位】
        移动第1位:00000000 00000000 00000000 00000010
        移动第2位:00000000 00000000 00000000 00000100
        结果是:00000000 00000000 00000000 00000100 【1<<2结果就是4】
         */
        System.out.println(a);
    }
}
```

3、无符号位移>>>：无符号右移运算符“>>>” - 同算数右移一样，但是结果会全变正数



#### 详情可以借鉴：https://blog.csdn.net/QGhurt/article/details/108692102

#### 建议：掌握以上的东西即可，不需要再深入了！



# 四、习题？

计算下列表达式的结果：

1、10/3 = ？

2、10/5 = ？

3、10%2 = ？

4、-10.5%3 = ？

答案解析：

```java
public class BinaryChange {
    public static void main(String[] args) {
        int a = 10 /3;
        System.out.println(a); // 输出：3
        int b = 10/5;
        System.out.println(b); // 输出：2
        int c = 10%2;
        System.out.println(c); // 输出：0
        double d = -10.5%3;
        System.out.println(d); // 输出：-1.5
    }
}
```

说出下列表达式的答案：

1、int i = 66；++i + i 的值是多少？

```java
public class BinaryChange {
    public static void main(String[] args) {
        int i = 66;
        System.out.println(++i + i); // 67 + 67 = 134
        //解析：++i：i = i+1，i = i,这里的i就为67
        System.out.println(i++ + i); // 66 + 67 = 133
        //解析：i++：i = i,i = i + 1,前一个i为66，后一个i为67
    }
}
```



