目录：

1、变量介绍【数据类型、变量基本使用、数据类型转换】

2、+ 号的使用

3、数据类型

4、编码

5、数据类型转换

# 一、为什么需要变量？

原因：变量是程序的基本组成部分

不论是使用哪一种高级语言编写程序，变量都是程序的基本组成单位。

变量的基本要素：类型 + 名称 + 值



# 二、变量的基本概念？

概念：相当于内存中一个数据存储空间的表示。可以把变量看作是一个房间的门牌号，拿着这个门牌号，就可以找到对应的房间，然后通过变量名，可以访问到里面的值

变量诠释：变就是变化，量就是值。变量又叫变化的值



# 三、变量的使用注意事项?

1、变量表示内存中的一个存储区域【不同的变量、类型不同，占用的空间大小也是不同的】

2、变量必须先声明，后使用。有顺序的，要现有变量再使用

3、该区域的数据/值只可以在同一个类型内变化

```java
int a = 1;
a = 'A'; // 报错，因为 a 属于int类型，不能将字符赋值给a
```

# 四、程序中 + 号的使用？

1、当左右两边都是数值型时，则作加法运算

2、当左右两边有一方为字符串，则作拼接运算



















# 一、数据类型？

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间（字节）。

为什么会出现数据类型？

解析：因为在我们的数据有大有小，假如不使用数据类型，就会浪费内存空间

# 二、数据类型---基本数据类型？

1、数值型：

1. 整型：存放整数（byte[1]、short[2]、int[4]、long[8]）
2. 浮点型：存放小数（float[4]、double[8]）

2、字符型：char[2]，存放单个字符，如'A'

3、布尔型：boolean[1]，存放true、false

#### 注意：引用数据类型此处暂时不讲，放到面向对象编程思想去讲



# 三、整型Int？

| 类型          | 占用内存空间 | 范围                   |
| :------------ | ------------ | ---------------------- |
| byte[字节]    | 1字节        | -128~127               |
| short[短整型] | 2字节        | -32768~32767           |
| int[整型]     | 4字节        | -2147483648~2147483647 |
| long[长整型]  | 8字节        | -2 * 63 ~ 2  *63-1     |

#### 注意：上述类型的范围为什么是那些？这个需要了解计算机的二进制存储机制，这个部分会在运算符部分进行讲解



# 四、整型的使用细节？

1、java各整类型有固定的范围和字段长度，不受os操作系统的影响，这样设计是为了保证java程序的可移植性

2、java的整型数据类型为int型，要声明其它的数据类型，必须在后面添加f/F、l/L

3、java程序中变量经常声明为int型，除非不足以表示大数，才会采用long

4、bit是计算机中的最小存储单位，byte是计算机中基本存储单元，1byte = 8bit【二进制再详细说】

图示计算机中进行存储的单元样式：

byte就是内存中开辟的比较大的空间，bit又是byte空间中的更小的小格子空间

比如：

byte n1 = 3;

short n2 = 3;

![image-20231014005238322](C:\Users\谭磊\AppData\Roaming\Typora\typora-user-images\image-20231014005238322.png)







# 五、浮点型float、double？

1、浮点数的分类

| 类型         | 占用存储空间 | 范围                 |
| ------------ | ------------ | -------------------- |
| 单精度float  | 4字节        | -3.403E38~3.403E38   |
| 双精度double | 8字节        | -1.798E308~1.798E3.8 |

2、说明

浮点数在计算机中的存储形式：浮点数 = 符号位 + 指数位 + 尾数位

位数部分可能会丢失，造成精度的损失（小数都是近似值）



# 六、浮点数细节？

1、与整数细节类似，Java浮点类型也有固定的范围和长度，不受具体的OS的影响

2、Java浮点型常量（具体值）默认为double类型，所以在声明float的时候是，需要在后面显示的添加上f/F

3、浮点型常量有两种表示方式：

```
十进制数形式：5.12、512.0f、.512（可以省略0，但是必须要有小数点）

科学计数法形式：5.12E2【等价于：5.12 * 10的2次方 = 512.0（带有512.0是因为是5.12是doube，所以后面也是等价于double类型）】
```

4、通常情况下，应该使用double类型，因为它比float更加精确

```java
double num9 = 2.1234567851;
float num10 = 2.1234567851F;
System.out.println(num9); // 2.1234567851
System.out.println(num10); // 2.1234567 精度损失
```



# 七、浮点型使用陷阱【比较需要进行运算的浮点数】？

1、2.7和8.1/3 比较：

```java
double num1 = 2.7;
double num2 = 8.1/3; // 输出：2.6999999999999997
if(num1 == num2) {
    System.out.println("相等"); 
};
if(num1 != num2) {
    System.out.println("不相等"); 
};// 输出这一条语句
```

2、这是为什么呢？

因为计算机在存储值的时候，是不像人这么智能的，无法判断8.1后面是否还有数字，再加上还要进行运算，所以得出来的结果就不是2.7这么精确的数字

3、那么如何进行避免呢？

```java
// 取两个值的差的绝对值，再用他们的绝对小于某一个数进行比较
// 这个某一个数是根据你的业务场景来的，比如：钱，最小只是到分，那么就用0.01
double num1 = 2.7;
double num2 = 8.1/3; // 输出：2.6999999999999997
if(Math.abs(num1 - num2) < 0.00001) {
    Sysytem.out.println("相等");
}
```



# 八、API文档的使用？

API（Application programming Interface）是应用程序编程接口，是Java提供的基本编程接口（Java提供的类还有相关的方法）

中文在线文档：https://www.matools.com

1、Java类的组织形式：【简而言之就是java是如何进行文档划分的】

![image-20231016203611070](C:\Users\谭磊\AppData\Roaming\Typora\typora-user-images\image-20231016203611070.png)

解析：在JDK中，有无数个包，每一个包下面又包含了接口、类、异常、枚举、错误。而在每一个类中，又包含了字段、构造器（构造方法）、成员方法（方法）

2、所以当你想要去使用一个方法的时候，需要先知道这个方法在哪一个包中，这个方法在哪一个类中，才能去找到和查看它

```java
// API 文档的使用：我们下载了jdk，jdk中含有jre + java的各类开发工具
// 当在开发中想要使用到某一个方法的时候，就需要去寻找到这个方法属于java中的哪一个类
// 如下：想要使用键盘输入，就在java中的util包中找到Scanner类
// 导入java.util包中的Scanner类，然后再实例化这个Scanner类
// 最后即可使用Scanner类下面的方法.next()
import java.util.Scanner;
public class Test {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入您的名字：");
        String name = scanner.next();
        System.out.println("您的名字是：" + name);
    }
}
```



#### 延申：如何理解字段？【就是私有化的变量】

```java
pubic class A {
    private String s = "123";
}
```

解析：通常叫做“类成员”，或 "类成员变量”，有时也叫“域”，理解为“数据成员”，用来承载数据的

1、我们可以说在A类中有一个成员变量叫s，A类有一个字段s

2、字段一般是用来承载数据的，所以为了安全性，一般定义为私有



# 九、字符型char？

字符型可以表示单个字符，字符型是char，char是两个字节（可以存放汉字）

char的本质是一个整数，因此可以从数字转换为字符，又可以从字符转                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     换为整数数字

多个字符我们使用字符串String（后面详细讲解String）

```java
char c1 = 'A';
char c2 = '你';
char c3 = '\t';
char c4 = 97; // 注意：这里不是输出97，而是输出97代表的单个字符

// 思考：我怎么知道某一个数字输出了什么字符呢？
// 这就涉及到了编码
```

# 十、字符型细节？

1、字符常量必须是使用的是单引号括起来的单个字符

```java
char c1 = 'a';
char c2 = '你';
```

2、java中还允许使用转义字符\来将其后面的字符转换为特殊的字符型变量

```java
char c3 = '\t'; // 注意：这里的 \t 不是代表两个字符，\只是起到转转义的作用，要和后面的字符组成一个整体
```

3、在java中，char的本质是一个整数，在输出的时候，是unicode码对应的字符

站长工具：http://tool.chinaz.com

4、可以直接给char赋一个整数，然后输出时，编译器会按照对应的unicode编码输出对应的字符，如下：

```java
char c4 = 97; // 输出：a
```

5、char类型是可以进行运算的【这是因为char的本质是一个整数】，而整数又有对应的 unicode 值

```java
// 1、输出字符
char c5 = 'a' + 1;
System.out.println(c5); // 输出：b

// 2、输出数字
char c6 = 'b' + 1;
System.out.println((int)c6); // 输出：99
```



# 十一、字符型本质?

字符本质探讨：

1、字符型存储到计算机中，需要将字符对应的码值（整数）找出来，比如'a':

存储：'a'===> 码值 97 ===>二进制（0110 0001）===>存储

读取：二进制（110 0001）===> 97 ===> 'a'

2、字符和码值的对应关系是通过字符编码表决定的（规定好的）

字符编码表的种类及其存储大小：

1、ASCII：ASCII编码表，1个字节表示，一共有128个字符【实际上1个字节可以表示256个字符，但是因为计算机是美国人发明的，所以只用了128个字符】！！！但是，因为只有128个字符，就会不适用其它国家，因为像中国、韩国、日本，这些国家的字符远远超过128甚至是256个，所以就有了下面的Unicode编码

```java
public class Test {
    public static void main(String[] args) {
        // 1byte = 8bit
        // 0000 0000
        // 每1位都有2中情况，总共有8位：那么结果就是：2^8
        // 2*2*2*2*2*2*2*2 = 2^8 = 256
    }
}
```



2、Unicode：unicode编码表，固定大小的编码表，使用2个字节来表示字符，字母和汉字都是占用两个字节！！！但是，都占用两个字节的话，就会很浪费空间。比如一篇文章，只有一个汉字，其它的全部是英文，英文都占用2个字节的话，那么就会造成空间的极大浪费，所以又衍生出了下面的utf-8编码

3、utf-8：utf-8编码表，大小可变的编码，字母使用的是1个字节，汉字使用的是3个字节【所以在开发中，我们的utf-8使用得是比较多的】

4、gbk：gbk编码，可以表示汉字，而且范围大，字母使用1个字节，汉字使用2个字节【虽然gbk也可以表示汉字，但是表示得范围是没有utf-8这么多的！！！所有有时候从utf-8转换为其gbk或者是其它得编码，会报错就是这个原因】

5、gb2312：gb2312编码，也可以表示汉字，但是使用得非常少【gb2312 < gbk】

6、big5：big5编码【表示繁体中文，多数为香港、台湾使用】



# 十二、常用编码及其故事含义解析？

1、ASCII：上个世纪60年代，美国制定了一套字符编码（使用1个字节），对英语字符与二进制之间的关系，做了统一规定，这被称为ASCII码！ASCII一共规定了128个字符编码，只占用了1个字节，后面的7位，最前面的1为统一规定为0。

特别提示：1个字节可以表示256个字符【因为1字节 = 8bit（这里的8bit就是0和1的个数），使用二进制就表示：00000000~11111111，共有256中组合方式，即使考虑符号位，也是有256位】

缺点：不能表示所有的字符！美国可以使用字母来组合，表示不同的意思，但是有的国家却不能，所以这种编码不适用全球，于是就有了下面的Unicode编码出现



2、Unicode：一种编码，将世界上的所有编码都纳入了其中，每一个符号都给于一个独一无二的编码，使用Unicode没有乱码的问题！

Unicode可以表示的字符范围是：2的16次方，所以最最多编码是在65536个字符【采用16进制来保存字符，计算机会转换为2进制，那么2的16次方就是65536】

Unicode编码的0~127和ASCII的0~127是一样的，比如：'a'在ASCII是0x61，在Unicode是0x0061，都对应97，因此Unicode兼容ASCII

缺点：一个英文字母和一个汉字都占用2个字节，于是就会造成存储空间的极大浪费！！【如：一篇文章，只有一个汉字，其它的全部是英文，英文都占用2个字节的话，那么就会造成空间的极大浪费】



3、UTF-8：对Unicode码的一种改进！utf-8是互联网上使用最广的一种Unicode实现方式！uft-8是一种变长的编码方式！可以使用1~6个字节表示一个符号，根据不同的符号而变化字节长度

utf-8使用大小可变的编码，字母占1个字节，汉字占用3个字节





# 十三、布尔类型boolean？

1、布尔类型也叫做boolean类型，Boolean的取值只允许有true和false，无null

2、boolean类型占1个字节

3、boolean类型适用于逻辑运算，一般用于程序流程控制【如：if条件控制语句、do-while循环控制语句、for循环控制语句】

使用细节：不可以使用0或者是非0的整数代替true和false，这点和c、php语言不同



# 十四、基本数据类型转换？【自动、强制】

## 一、自动类型转换★★★★★★★★★★

当java程序在进行赋值或者是运算的时候，精度小的类型自动转换为精度大的数据类型。这个就是自动转换

1、数据类型按照精度的大小：从小到大的两种排序【直接背下来】

char ==> int ==> long ==> float ==> double

byte ==> short ==> int ==> long ==> float ==>double

## 二、自动类型转换的细节和注意事项？

1、多种数据混合运算时，系统首先将所有数据转换为容量最大的那种数据类型，然后再进行计算

```java
// 案例：
int n1 = 10;
float f1 = n1 + 1.1; // 错误：因为1.1类型是double，所以n1+1.1的类型为double！按照自动类型转换顺序来说，double是无法赋值给到float的，所以编译错误

// 改进：
int n1 = 10;
float f1 = n1 + 1.1F; // 添加float标识符
// 或
double d1 = n1 + 1.1; // 直接使用double来进行接收
```

2、当我们把精度（容量）大的数据类型赋值给到精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换

```java
// 自动类型转换规则
char ==> int ==> long ==> float ==> double

byte ==> short ==> int ==> long ==> float ==>double
```

3、byte和char、short之间不会相互自动转换

```java
// 这也是为什么会出现以下这2个数据类型转换规则的原因
char ==> int ==> long ==> float ==> double

byte ==> short ==> int ==> long ==> float ==>double
```

4、byte、char、short，三者之间可以进行运算！但是在运算的时候会转换为int类型，无论是byte + byte，还是 char + char，short + short！又或者是byte + short + char，short + byte，short + char，char + byte

【简而言之：byte、char、short着三种数据类型，不论是单类型运算还是混合类型运算，都会转换为int类型】

```java
// byte 类型
byte b1 = 1;
byte b2 = 2;
// short 类型
short s1 = 3;
short s2 = 4;
// char 类型
char c1 = 'a';
char c2 = 'b';

// 同类型
byte B = b1 + b2; 
short S = s1 + s2;
char C = c1 + c2;
// 错误：因为同类型运算会转换为int，把int赋值给byte、short、char会报错!!！

// 混合类型
byte b = s1 + c1;
short s = c1 + b1;
char c = b1 + s1;
// 错误：因为混合类型运算也会转换为int，把int赋值给byte、short、char会报错!!！
```

5、boolean类型不参与数据类型转换，从上面的2条转换信息就可以看出来

6、自动提升原则：在混合运算中，如果参杂的数据类型太多，整个表达式的数据类型自动转换为操作数中最大的类型

```java
byte b1 = 1;
short s1 = 100;
int i1 = 25;
float f1 = 30.1F;

float d = b1 + s1 + i1 + f1; // 这里面精度（容量）最大的是float，所以使用folat来接收数据是没有问题的！

double d = b1 + s1 + i1 + f1; // 这里面精度（容量）最大的是float，所以使用double来接收数据也是没有问题的！

```



## 三、强制类型转换★★★★★★★★★★

强制类型转换是自动类型转换的逆过程，将容量大（精度高）的数据类型转换为容量小（精度小）的数据类型。

使用时要在前面加上强制转换符和要转换为的数据类型：(char/byte/short/int/long/float/double )

```java
int n1 = 2000;
byte b1 = (byte)n1;
```

强制类型转换这一个过程，程序员自我意识必须特别清晰，并且需要清晰的知道强制类型转换将会带来什么样的后果！！！【如：精度损失、数据溢出】

1、精度损失：一般发生在将`浮点型数据`转换为`整数型数据`上。因为是存储整数，所以浮点型的小数位会被去掉，只留下整数，最终会造成数据损失。【计算机不管四舍五入】

```java
double d1 = 12345.845202;
int i1 = (int)d1; // 12345
```

2、数据溢出：范围不匹配：强制类型转换中，通常是将一个较大范围的数据类型转换为一个较小范围的数据类型。如果原始数据类型在目标数据类型的表示范围之外！！！那么此时就会出现数据溢出

```java
int i1 = 2000;
byte b1 = (byte)i1; // 输出：-47 出现数据溢出，因为byte的范围在-128~127之间，显然i1的值超出了b1的表示范围，所以就会出现数据溢出
```

## 四、强制类型转换的细节和注意事项？

1、当进行转换的数据类型的容量（精度）是从大==>小，就需要使用到强制类型转换

2、强转符号：( ) 只对最近的操作数有效，假如想要转换一个表达式，需要使用小括号

```java
int x = (int)10 * 3.5 + 6 * 1.5; // int只对10有效，后面的依旧是double类型，而且左边都是double类型，所以会报错！

int x = (int)(10 * 3.5 + 6 * 1.5);  // 正确，输出：44
```

3、char类型可以保存int的常量值，但是不能保存int的变量值！假如想要保存，就需要使用强转

```java
char c1 = 100; // 正确
int m = 100; // 正确
char c2 = m; // 因为m是int类型，将int类型赋值给char，直接报错
char c3 = (char)m; // 正确，m是int型，可以转换为char型
```

4、char、byte和short在进行运算的时候，会自动转换为int类型是，不论是单类型运算还是混合运算

```java
// byte 类型
byte b1 = 1;
byte b2 = 2;
// short 类型
short s1 = 3;
short s2 = 4;
// char 类型
char c1 = 'a';
char c2 = 'b';

// 同类型
byte B = b1 + b2; 
short S = s1 + s2;
char C = c1 + c2;
// 错误：因为同类型运算会转换为int，把int赋值给byte、short、char会报错!!！

// 混合类型
byte b = s1 + c1;
short s = c1 + b1;
char c = b1 + s1;
// 错误：因为混合类型运算也会转换为int，把int赋值给byte、short、char会报错!!！
```



# 十五、String和基本数据类型转换？

在程序开发中，我们经常需要将基本数据类型转换为String类型，或者将String类型转换为基本数据类型

## 一、基本数据类型转换为String类型

语法：将基本数据类型的值 + "" 即可

```java
// 以下是基本数据类型
byte B = 5;
short s = 15;
int n = 100;
float f = 1.1F;
double d = 3.4;
boolean b = true;

// 以下是转换为字符串String类型
String str1 = B + "";
String str2 = s + "";
String str3 = n + "";
.....
```

## 二、String类型转换为基本数据类型

语法：通过基本类型的包装类【每一个基本类型都包含自己的包装类】调用parseXX方法即可

```java
// 这是一个String据类型
String s = "123";

// 转换为基本数据类型:

// byte类型
Byte.parseByte(s); // 这里的Byte就是byte的包装类！！parseByte是byte包装类Byte下的方法

// short类型
Short.parseShort(s); // ....

// int类型
Integer.parseInt(s); // ....

// long类型
Long.parseLong(s); // ....

// float类型
Float.parseFloat(s); // ....

// double类型
Double.parseDouble(s); // ....

// 当然了，布尔值是无法使用字符串进行转换的，只能转换自己false和true值
String s1 = "true";
Boolean.parseBoolean(s1);
```

## 三、看完上面这两种转换方式，你一定很疑惑，为什么没有char字符类型与String字符串类型进行转换？

这是因为char是字符，而String是字符串，想要转换，那么char只可以接收String中的某一个字符，如下：

```java
String s = "你是我的爱人";

// 转换为char
s.charAt(0); // 输出：你

// 解析：这里使用到了charAt这个方法，这个方法是以下标为来源，获取到相应的元素！例如：上面的 charAt(0)获取到了s中的 "你"！！下面再给一个例子加深印象
String num = "123";
s.charAt(1); // 输出：2
```

假设你不指定下标，则字符串的第一个字符默认被取出！

#### 如果想要将char类型转换为String语句：只需要像基本数据类型一样使用+号进行拼接就可以了

```java
public class Test {
    public static void main(String[] args) {
        char c = '谭';
        String str = c + "";
        System.out.println(str);
    }
}
```





# 十六、String转基本数据类型细节？

1、将String类型转换为基本数据类型的时候，要确保String类型能够转换成为有效的数据，比如我们可以将"123"转换为一个整数，但是不能将"hello"转换为一个整数，因为计算机不知道怎么办！

```java
String s = "123";
Integer.parseInt(s); // 输出：123
```

2、如果格式不正确，计算机器就会抛异常，程序就会终止，这个问题在异常处理章节，会进行专门的处理

```java
String s = "hello";
Integer.parseInt(s);
// 计算机在编译的时候会通过，但是在运行的时候会抛出Exception错误！！一旦遇到Exception，程序就会终止运行！！

// 在后面面向对象中的时候，会专门去处理这个异常！
```



