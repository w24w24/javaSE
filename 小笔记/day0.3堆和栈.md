# 一、堆和栈？

## <span style="color:red">一、堆和栈的产生</span>

先说一个故事：按照顺序来看

1、计算机中有一块CPU，CPU中有一个核心模块叫“ALU”，是用来做逻辑运算和数学运算的

2、人类在做复杂式子计算的时候，先计算出其中的某一个结果，暂且将这个结果称之为“临时结果”，然后再用这个临时结果去和剩下的式子计算

3、计算机中CPU的ALU也是这样的，在计算复杂式子的时候，就会先产生一个“临时结果”，但是这些临时结果放置在哪呢？

4、于是CPU的设计师们在CPU中又设计了一些可以“存放数字”的模块，这个模块就叫做“寄存器”，名字分别叫AX、BX、CX、DX... 

5、有了寄存器，ALU就可以把计算的结果保存在寄存器中，需要使用的时候再拿出来，这就解决了复杂式子计算的问题

6、为了实现更复杂的式子计算，可不可以做更多的寄存器？

7、答案是不能，这是因为会增加CPU的复杂性以及成本，所以只能从外部请帮手了

8、而且这个外部帮手的关键特点就是：读写速度要快，因为CPU的速度非常的快，假如这个外部帮手慢了，那么计算机就会很慢

9、从硬盘、软盘、光盘、内存中选出了内存，因为其它的速度都没有内存这么快

10、而内存中包含了栈和堆



## <span style="color:red">二、栈的概念</span>

1、既然要在内存中存储数据，就需要划出一块专门的区域来临时存储数据了，这个专门的区域就叫做“栈stack”【堆暂没学】

<span style="color:red">栈的本质：栈的本质就是内存中的一个区域</span>

2、栈的特殊之处在于CPU从内存的栈中存取数据的方式

<span style="color:red">形象例子：弹夹装子弹</span>

<span style="color:red">1、把一个个的子弹往里面压进去，压进去这个动作就是：进栈/入栈</span>

<span style="color:red">2、最先压进去的，处于弹夹的最下面，在射击的时候，这颗子弹会最后一个被打出去，简而言之就是：先入后出，对应的就是：后入先出</span>

<span style="color:red">3、CPU觉得这种操作方式非常好，所以决定对栈和堆的操作都遵循弹夹操作的规律</span>

3、当把数据在栈中存储完毕之后，CPU想要拿到数据，所以就会从栈复制一份数据到寄存器中，但是这个时候栈中的数据还是存在的，只是已经被当作垃圾进行回收了

<span style="color:red">形象例子：把子弹打出去</span>

<span style="color:red">1、打出去这个动作就是：出栈/弹栈</span>

<span style="color:red">2、而掉落的弹壳就是：垃圾</span>



## <span style="color:red">三、栈堆和函数调用</span>

程序运行：

1、程序在运行的时候，是以机器码的形式存储在内存中的

2、每一句机器码都有自己的位置，这个位置称之为“地址”

3、CPU执行程序的过程，就是把程序中的每一句机器码挨个拿过来，分析出这句机器码是干啥的，然后再计算机上做出相应的操作，如：该计算的计算、该取数据的取数据、该跳转的跳转、该死机的死机

=============================================================

<span style="color:red">函数：其实就是一堆代码的“打包”</span>

函数调用：就是CPU在执行代码时，临时跳转到调用的函数上，去执行调用的这个函数，执行完毕之后再跳转回来，<span style="color:red">专业术语：函数跳转和返回</span>

1、CPU在调用函数的时候，也会使用到堆和栈

2、在“调用函数”的时候，CPU会把函数所在的地址压栈/入栈

3、在“返回函数”的时候，CPU会把函数所在的地址弹栈/出栈，CPU就可以拿到这个地址





## <span style="color:red">堆和栈存数据：先将数据存储在内存中，内存中分为栈和堆，这两个空间存储的数据类型不同【这里不必深究】。存储数据的这个行为就叫做入栈/进栈，当需要使用到数据，拿到数据的时候，这个就叫做出栈/弹栈</span>



为什么一定要使用堆和栈来存储数据呢？

因为很多时候，函数调用都是嵌套的，也就是套娃，而且函数调用之后又需要返回，这种频繁、有次序的存数据和取数据的操作，使用堆和栈是最合适的。<span style="color:red">每一次调用函数都会消耗堆和栈的一些空间，而整个堆和栈的空间大小是有限的(固定的)，如果函数不停的调用，但是不返回(返回就意味着销毁)，堆栈就会被占满，这个时候再试图将数据压栈就会导致错误，这个错误也叫做：栈溢出Stack Overflow，一旦栈溢出，程序也就崩溃了</span>



