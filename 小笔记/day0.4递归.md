# 一、递归

#### “递归”包含两个关键部分：一下两个概念都是在诠释“函数自己调用自己”

1、递推关系：这是描述问题规模减小的方式，即将原始问题转化为更小规模的子问题的规则

2、基本情况：这是递归的终止条件，定义了问题的最小规模，不需要再继续递归的情况

#### “递归”二字解析：

1、递：通常指的是函数调用自己本身

2、归：通常是指问题规模逐渐减小直至达到基本情况

## <span style="color:red">一、形象示例：</span>

the shy拿了2018年的世界冠军

(使用了递归后)

the shy拿了2018年的世界冠军

(再使用递归)

the shy拿了2018年的世界冠军

.....

##  <span style="color:red">递归的核心理念：同样的故事中再提到同样的故事</span>



## 二、在编程中的递归

递归：就是一个函数在运行的时候自己调用自己

1、代码示例：

```java
// 一个公共类【一个程序只允许有一个public修饰的class类】
public class Test {
    // 这是程序执行的入口，也就是我们的main主方法
    public static void main(String[] args) {
        SolveSum res = new SolveSum();
        int numberSum = res.numberSum(100);
        System.out.println(numberSum); // 输出：5050
    }
}
// 这是一个基本类
class SolveSum {
    public int numberSum(int number) {
        // 需要一个限制条件来限制递归，否则无线递归会导致“Stack Overflow”
        if(number > 0) {
            return number + numberSum(number - 1);
        }
        return number;
    }
}

// 解析：numberSum已经是一个函数了，但是在函数的内部，它又调用了自己，所以这种自己调用自己的形式就叫做递归
```

## 三、为什么会导致“栈溢出”

解析：这是因为在程序运行的时候，调用函数是有代价的，代价就是：<span style="color:red">会占用一个叫做栈“Stack”的内存空间。当调用函数的时候，都必须要放一些数据到栈里，当函数运行结束的时候，这些数据会被从栈中取出【取出就是return出去】，一旦取出，也就是return出去，就意味着栈中的数据可以被当作垃圾进行销毁了。可想而知，如果调用了很多的函数，但是并没有取出，也就是没有return出去，那么就会造成栈空间堵塞，栈会被塞满，也就会造成数据没有空间可以存放，没有空间存放，那么这个这些数据就会导致栈溢出“Stack Overflow”，对于程序而言，这种错误是致命的，因为一旦栈溢出错误，操作系统就会强制终止程序</span>

#### <span style="color:red">深度：递归调用次数就叫做深度，启用人为设置深度是为了保证程序不会崩溃，从而满足程序员的开发需求</span>

## 四、总结

1、递归：就是函数自己调用自己

2、只递不归会导致程序崩溃：因为“递”是在不断的调用函数，但是不“归”，则是永远没有尽头，所以会造成栈溢出，导致程序崩溃【口诀：有递就要有归，只递不归会造成程序崩溃】

3、为了避免崩溃，递归函数中一定要包括<span style="color:red">条件语句，在合适的时候终止递归。这个条件语句就像是if语句中的条件语句一样，用来限制递归不会一直进行下去，从而导致栈溢出情况</span>

